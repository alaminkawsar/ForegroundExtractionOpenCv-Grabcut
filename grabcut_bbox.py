# import the necessary packages
import numpy as np
import argparse
import time
import cv2
from matplotlib import pyplot as plt
import os

image = cv2.imread("input.jpg")
mask = np.zeros(image.shape[:2], dtype="uint8")

rect = (151, 43, 236, 368)

fgModel = np.zeros((1, 65), dtype="float")
bgModel = np.zeros((1, 65), dtype="float")
# apply GrabCut using the the bounding box segmentation method
start = time.time()
(mask, bgModel, fgModel) = cv2.grabCut(image, mask, rect, bgModel,
	fgModel, iterCount=5, mode=cv2.GC_INIT_WITH_RECT)
end = time.time()
print("[INFO] applying GrabCut took {:.2f} seconds".format(end - start))

values = (
	("Definite Background", cv2.GC_BGD),
	("Probable Background", cv2.GC_PR_BGD),
	("Definite Foreground", cv2.GC_FGD),
	("Probable Foreground", cv2.GC_PR_FGD),
)

outputMask = np.where((mask == cv2.GC_BGD) | (mask == cv2.GC_PR_BGD),
	0, 1)
# scale the mask from the range [0, 1] to [0, 255]
outputMask = (outputMask * 255).astype("uint8")
# apply a bitwise AND to the image using our mask generated by
# GrabCut to generate our final output image
output = cv2.bitwise_and(image, image, mask=outputMask)

# loop over the possible GrabCut mask values
# for (name, value) in values:
#     # construct a mask that for the current value
#     print("[INFO] showing mask for '{}'".format(name))
#     valueMask = (mask == value).astype("uint8") * 255
#     # display the mask so we can visualize it
#     plt.imshow(valueMask)
#     plt.show()

plt.imshow(image)
plt.show()

plt.imshow(outputMask)
plt.show()

plt.imshow(output)
plt.show()
